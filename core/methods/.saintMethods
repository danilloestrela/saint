#!/bin/bash
#Templates for creating new projects

# Returns the list of current projects
saint_project_list() {
  # Count the number of projects
  local projectCount=0
  local projects=("${SAINT_PROJECTS_FOLDER}/"*)

  for project in "${projects[@]}"; do
    if [ -f "${project}/.${projName}" ]; then
      let projectCount+=1
    fi
  done

  # Display message based on the number of projects
  if [ "$projectCount" -eq 1 ]; then
    saint_msg "This is the project you have now:"
  else
    saint_msg "These are the projects you have now:"
  fi

  # ${newProjName} over existing projects and list them
  for project in "${projects[@]}"; do
    if [ -d "$project" ]; then
      local projName=$(basename "$project")
      local aliasFile="${project}/.alias"

      if [ -f "$aliasFile" ]; then
        local aliasLine=$(sed -n '3p' "$aliasFile")
        # Extract the alias shortcut (everything between alias and =)
        local aliasShortcut=$(echo "$aliasLine" | sed 's/alias \([^=]*\)=.*/\1/')
        echo "${projName} (${aliasShortcut})"
      fi
    fi
  done
}

saint_get_project_list_from_folders_array() {
  local projects=("$@")
  local project_list=()
  for project in "${projects[@]}"; do
    local projName=$(basename "$project")
    if [ -f "${project}/.${projName}" ]; then
      project_list+=("$projName")
    fi
  done
  echo "${project_list[@]}"
}

saint_add_command() {
  local project_name=$1
  local project_name_for_bash=$(echo "$project_name" | sed 's/-/_/g')
  local command="\ \ \ \ \ \ \ \ ${project_name}) ${project_name_for_bash}_main_commands \"\${projectCommand} \$1\" \${@:2};;"
  if ! grep -q "${command}" ${SAINT_METHODS_MAIN_COMMANDS_FILE}; then
    if [[ "$OSTYPE" == "darwin"* ]]; then
      sed -i '' "/#BEGIN-MAIN-COMMANDS/a\\
${command}
" ${SAINT_METHODS_MAIN_COMMANDS_FILE}
    else
      sed -i "/#BEGIN-MAIN-COMMANDS/a ${command}" ${SAINT_METHODS_MAIN_COMMANDS_FILE}
    fi
    if [ $? -ne 0 ]; then
      saint_msg_status "error" "Failed to add command for project ${YELLOW}${project_name}${NC}."
      return 1
    fi
  fi

}

saint_remove_command() {
  local project_name=$1
  local project_name_for_bash=$(echo "$project_name" | sed 's/-/_/g')
  local command="\ \ \ \ \ \ \ \ ${project_name}) ${project_name_for_bash}_main_commands \"\${projectCommand} \$1\" \${@:2};;"
  if [[ "$OSTYPE" == "darwin"* ]]; then
    sed -i '' "/${command}/d" ${SAINT_METHODS_MAIN_COMMANDS_FILE}
  else
    sed -i "/${command}/d" ${SAINT_METHODS_MAIN_COMMANDS_FILE}
  fi
}

saint_validate_project_files() {
  local project_dir=$1
  local project_name=$2
  local mandatory_files=(".alias" ".${project_name}" ".mainCommands" ".variables")
  for file in "${mandatory_files[@]}"; do
    if [ ! -f "${project_dir}/${file}" ]; then
      saint_msg_status "error" "Missing mandatory file ${YELLOW}${file}${NC} in project ${YELLOW}${project_name}${NC}."
      return 1
    fi
  done
  return 0
}

saint_load_project_commands() {
  local project_name

  # Check if the SAINT_PROJECTS_FOLDER exists, if not, create it
  if [ ! -d "${SAINT_PROJECTS_FOLDER}" ]; then
    mkdir -p "${SAINT_PROJECTS_FOLDER}"
  fi

  # Check if the projects directory exists and contains folders
  if [ -d "${SAINT_PROJECTS_FOLDER}" ] && [ "$(find ${SAINT_PROJECTS_FOLDER} -mindepth 1 -type d | head -n 1)" ]; then
    for project_dir in "${SAINT_PROJECTS_FOLDER}/"*; do
      if [ -d "$project_dir" ]; then
        project_name=$(basename "$project_dir")
        if saint_validate_project_files "$project_dir" "$project_name"; then
          saint_add_command "$project_name"
        fi
      fi
    done
  else
    saint_msg_status "info" "No projects found in ${YELLOW}${SAINT_PROJECTS_FOLDER}${NC}."
    return 1
  fi

}

saint_update_project_commands() {
  # Check if template has been updated and sync if necessary
  local templatePath="${PROJECT_PATH}/templates/saint_temps/.saintMainCommands.txt"
  local currentFile="${SAINT_METHODS_MAIN_COMMANDS_FILE}"

  # Compare template with current file to see if update is needed
  if [ -f "$templatePath" ] && [ -f "$currentFile" ]; then
    if ! cmp -s "$templatePath" "$currentFile"; then
      saint_msg_status "info" "Template has been updated, syncing main commands..."
      # Copy template to current file
      cp "$templatePath" "$currentFile"
      saint_msg_status "success" "Main commands template synced"
    fi
  fi

  # Clear commands between BEGIN and END
  if [[ "$OSTYPE" == "darwin"* ]]; then
    sed -i '' '/#BEGIN-MAINCOMMANDS/,/#END-MAINCOMMANDS/{//!d;}' ${SAINT_METHODS_MAIN_COMMANDS_FILE}
  else
    sed -i '/#BEGIN-MAINCOMMANDS/,/#END-MAINCOMMANDS/{//!d;}' ${SAINT_METHODS_MAIN_COMMANDS_FILE}
  fi

  saint_load_project_commands
  saint_msg_status "success" "Project commands updated successfully."
}

# Force sync main commands template
saint_sync_main_commands() {
  local templatePath="${PROJECT_PATH}/templates/saint_temps/.saintMainCommands.txt"
  local currentFile="${SAINT_METHODS_MAIN_COMMANDS_FILE}"

  if [ ! -f "$templatePath" ]; then
    saint_msg_status "error" "Template file not found: $templatePath"
    return 1
  fi

  if [ ! -f "$currentFile" ]; then
    saint_msg_status "error" "Current commands file not found: $currentFile"
    return 1
  fi

  # Force sync template
  cp "$templatePath" "$currentFile"
  saint_msg_status "success" "Main commands template synced from template"

  # Reload project commands
  saint_update_project_commands
}

saint_initialize_main_commands() {
  if [ ! -d "${SAINT_TEMP_FOLDER}" ]; then
    mkdir "${SAINT_TEMP_FOLDER}"
  fi;

  if [ ! -f ${SAINT_METHODS_MAIN_COMMANDS_FILE} ] || [ ! -d $SAINT_TEMP_FOLDER ]; then
    local templatePath="${PROJECT_PATH}/templates/saint_temps/.saintMainCommands.txt"
    local fileNameWithPath="${SAINT_METHODS_MAIN_COMMANDS_FILE}"
    # Reading template content
    local templateContent=$(<"$templatePath")
    # Writing writing new contents on the path
    echo "$templateContent" > "$fileNameWithPath"
    saint_update_project_commands && saint_rebuild_help || return 1
  else
    return 1
  fi
}

# Update command handler
saint_handle_update() {
    saint_update_commands "$@"
}

# Reload command handler
saint_handle_reload() {
    saint_reload
}

# Debug command handler
saint_handle_debug() {
    case "$1" in
        on|enable|true|1)
            touch "${SAINT_DEBUG_FILE}"
            saint_msg_status "success" "Debug mode enabled"
            saint_msg_status "info" "Debug file: ${SAINT_DEBUG_FILE}"
            saint_msg_status "info" "Debug messages will now be displayed"
            ;;
        off|disable|false|0)
            if [[ -f "${SAINT_DEBUG_FILE}" ]]; then
                rm "${SAINT_DEBUG_FILE}"
                saint_msg_status "success" "Debug mode disabled"
                saint_msg_status "info" "Debug messages will no longer be displayed"
            else
                saint_msg_status "info" "Debug mode was already disabled"
            fi
            ;;
        status|check)
            if saint_is_debug_active; then
                saint_msg_status "success" "Debug mode is ACTIVE"
                saint_msg_status "info" "Debug file: ${SAINT_DEBUG_FILE}"
            else
                saint_msg_status "info" "Debug mode is INACTIVE"
                saint_msg_status "info" "Use 'saint debug on' to enable"
            fi
            ;;
        help|"")
            echo "ðŸ¤– Saint Debug Management"
            echo "========================"
            echo ""
            echo "Available commands:"
            echo ""
            echo "on|enable|true|1     - Enable debug mode"
            echo "off|disable|false|0  - Disable debug mode"
            echo "status|check         - Check debug mode status"
            echo "help                 - Show this help message"
            echo ""
            echo "Examples:"
            echo "  saint debug on          # Enable debug mode"
            echo "  saint debug off         # Disable debug mode"
            echo "  saint debug status      # Check current status"
            echo ""
            echo "Debug messages will only appear when debug mode is active"
            echo "Debug file location: ${SAINT_DEBUG_FILE}"
            ;;
        *)
            saint_msg_status "error" "Unknown debug command: $1"
            saint_msg_status "info" "Use 'saint debug help' for available commands"
            return 1
            ;;
    esac
}

# Handle version management commands
saint_handle_version() {
    case "$1" in
        bump|-b)
            saint_version_bump "$2"
            ;;
        tag|-t)
            saint_version_tag
            ;;
        undo|-u)
            saint_version_undo
            ;;
        history|-i)
            saint_version_history_show
            ;;
        sync|-s)
            saint_version_sync
            ;;
        help|-h)
            saint_version_help
            ;;
        "")
            saint_version
            ;;
        *)
            saint_msg_status "error" "Unknown version command: $1"
            saint_msg_status "info" "Use 'saint version help' for available commands"
            return 1
            ;;
    esac
}


source "${PROJECT_PATH}/core/features/methods/saint_help_manager/.saintHelpManager"
source "${PROJECT_PATH}/core/features/methods/saint_template_manager/.saintTemplateManager"
source "${PROJECT_PATH}/core/features/methods/saint_project_manager/.saintProjectManager"
