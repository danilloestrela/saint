#!/bin/bash

# Saint Auto-Update System
# Provides automatic version checking and updating

# Auto-update system uses centralized variables from .saintVariables
# All variables are defined in core/variables/.saintVariables

# Check if update check is needed
saint_should_check_update() {
    if [ ! -f "${SAINT_UPDATE_CHECK_FILE}" ]; then
        return 0  # No check file, should check
    fi
    
    local last_check=$(cat "${SAINT_UPDATE_CHECK_FILE}" 2>/dev/null)
    local current_time=$(date +%s)
    local time_diff=$((current_time - last_check))
    local days_diff=$((time_diff / 86400))  # Convert seconds to days
    
    [ $days_diff -ge $SAINT_UPDATE_INTERVAL ]
}

# Mark update check as completed
saint_mark_update_check() {
    date +%s > "${SAINT_UPDATE_CHECK_FILE}"
}

# Get latest version from GitHub
saint_get_latest_version() {
    local latest_version=""
    local response=""
    local http_code=""
    
    # Try to get latest tag with better error handling
    if command -v curl &> /dev/null; then
        # Use curl with HTTP status code checking and timeout
        response=$(curl -s -w "%{http_code}" --max-time 10 "${SAINT_GITHUB_API}/tags" 2>/dev/null)
        http_code="${response: -3}"
        response="${response%???}"
        
        if [ "$http_code" = "200" ] && [ -n "$response" ]; then
            # Get the first (latest) tag and remove 'v' prefix
            latest_version=$(echo "$response" | \
                           grep '"name"' | \
                           head -1 | \
                           sed 's/.*"name": "v\([^"]*\)".*/\1/' 2>/dev/null)
        else
            saint_debug "GitHub API returned HTTP $http_code"
            saint_debug "Response: ${response:0:100}..."
        fi
    elif command -v wget &> /dev/null; then
        # Use wget with error checking and timeout
        response=$(timeout 10 wget -qO- --server-response "${SAINT_GITHUB_API}/tags" 2>&1)
        if [ $? -eq 0 ]; then
            # Get the first (latest) tag and remove 'v' prefix
            latest_version=$(echo "$response" | \
                           grep '"name"' | \
                           head -1 | \
                           sed 's/.*"name": "v\([^"]*\)".*/\1/' 2>/dev/null)
        else
            saint_debug "wget failed: $response"
        fi
    else
        saint_debug "Neither curl nor wget is available"
    fi
    
    # Validate the version format
    if [ -n "$latest_version" ] && [[ "$latest_version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "$latest_version"
    else
        saint_debug "Invalid version format received: '$latest_version'"
        echo ""
    fi
}

# Check if first version is newer than second version
saint_is_version_newer() {
    local version1="$1"
    local version2="$2"
    
    # Validate inputs
    if [ -z "$version1" ] || [ -z "$version2" ]; then
        return 1  # Can't compare
    fi
    
    # Validate version format
    if ! [[ "$version1" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || ! [[ "$version2" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        return 1
    fi
    
    # Parse version parts
    local v1_major=$(echo "$version1" | cut -d. -f1)
    local v1_minor=$(echo "$version1" | cut -d. -f2)
    local v1_patch=$(echo "$version1" | cut -d. -f3)
    
    local v2_major=$(echo "$version2" | cut -d. -f1)
    local v2_minor=$(echo "$version2" | cut -d. -f2)
    local v2_patch=$(echo "$version2" | cut -d. -f3)
    
    # Validate that all parts are numeric
    if ! [[ "$v1_major" =~ ^[0-9]+$ ]] || ! [[ "$v1_minor" =~ ^[0-9]+$ ]] || ! [[ "$v1_patch" =~ ^[0-9]+$ ]] || \
       ! [[ "$v2_major" =~ ^[0-9]+$ ]] || ! [[ "$v2_minor" =~ ^[0-9]+$ ]] || ! [[ "$v2_patch" =~ ^[0-9]+$ ]]; then
        return 1
    fi
    
    # Compare major version
    if [ "$v1_major" -gt "$v2_major" ]; then
        return 0  # version1 is newer
    elif [ "$v1_major" -lt "$v2_major" ]; then
        return 1  # version2 is newer
    fi
    
    # Compare minor version
    if [ "$v1_minor" -gt "$v2_minor" ]; then
        return 0  # version1 is newer
    elif [ "$v1_minor" -lt "$v2_minor" ]; then
        return 1  # version2 is newer
    fi
    
    # Compare patch version
    if [ "$v1_patch" -gt "$v2_patch" ]; then
        return 0  # version1 is newer
    fi
    
    return 1  # version2 is newer or equal
}

# Compare versions
saint_compare_versions() {
    local current="$1"
    local latest="$2"
    
    # Validate inputs
    if [ -z "$latest" ] || [ -z "$current" ]; then
        saint_debug "Version comparison failed: current='$current', latest='$latest'"
        return 1  # Can't determine latest version
    fi
    
    # Validate version format
    if ! [[ "$current" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]] || ! [[ "$latest" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        saint_debug "Invalid version format: current='$current', latest='$latest'"
        return 1
    fi
    
    # Simple version comparison (assumes semantic versioning)
    local current_major=$(echo "$current" | cut -d. -f1)
    local current_minor=$(echo "$current" | cut -d. -f2)
    local current_patch=$(echo "$current" | cut -d. -f3)
    
    local latest_major=$(echo "$latest" | cut -d. -f1)
    local latest_minor=$(echo "$latest" | cut -d. -f2)
    local latest_patch=$(echo "$latest" | cut -d. -f3)
    
    # Validate that all parts are numeric
    if ! [[ "$current_major" =~ ^[0-9]+$ ]] || ! [[ "$current_minor" =~ ^[0-9]+$ ]] || ! [[ "$current_patch" =~ ^[0-9]+$ ]] || \
       ! [[ "$latest_major" =~ ^[0-9]+$ ]] || ! [[ "$latest_minor" =~ ^[0-9]+$ ]] || ! [[ "$latest_patch" =~ ^[0-9]+$ ]]; then
        saint_debug "Non-numeric version parts: current=$current_major.$current_minor.$current_patch, latest=$latest_major.$latest_minor.$latest_patch"
        return 1
    fi
    
    # Compare major version
    if [ "$latest_major" -gt "$current_major" ]; then
        echo "major"
        return 0
    elif [ "$latest_major" -lt "$current_major" ]; then
        return 1
    fi
    
    # Compare minor version
    if [ "$latest_minor" -gt "$current_minor" ]; then
        echo "minor"
        return 0
    elif [ "$latest_minor" -lt "$current_minor" ]; then
        return 1
    fi
    
    # Compare patch version
    if [ "$latest_patch" -gt "$current_patch" ]; then
        echo "patch"
        return 0
    fi
    
    return 1  # No update needed
}

# Show update notification
saint_show_update_notification() {
    local current_version="$1"
    local latest_version="$2"
    local update_type="$3"
    
    # Capitalize first letter safely
    local update_type_cap=""
    if [ -n "$update_type" ]; then
        update_type_cap=$(echo "$update_type" | sed 's/^./\U&/')
    fi
    
    echo ""
    echo "🔄 ${YELLOW}Update Available!${NC}"
    echo "================================"
    echo "Current Version: ${GREEN}${current_version}${NC}"
    echo "Latest Version:  ${GREEN}${latest_version}${NC}"
    echo "Update Type:     ${GREEN}${update_type_cap}${NC}"
    echo ""
    echo "To update, run: ${GREEN}saint update auto${NC}"
    echo "To check later: ${GREEN}saint update check${NC}"
    echo ""
}

# Check for updates
saint_check_for_updates() {
    local current_version="${SAINT_VERSION}"
    local latest_version=$(saint_get_latest_version)
    
    if [ -z "$latest_version" ]; then
        saint_msg_status "warning" "Could not check for updates"
        saint_msg_status "info" "Possible causes:"
        saint_msg_status "info" "  • Network connectivity issues"
        saint_msg_status "info" "  • GitHub API rate limiting"
        saint_msg_status "info" "  • GitHub service unavailable"
        saint_msg_status "info" "  • Missing curl/wget command"
        saint_msg_status "info" "Try again later or check your internet connection"
        return 1
    fi
    
    saint_debug "Comparing versions: current=$current_version, latest=$latest_version"
    
    # Check if this would be a downgrade
    if saint_is_version_newer "$current_version" "$latest_version"; then
        saint_msg_status "warning" "Downgrade detected!"
        saint_msg_status "info" "Current version ($current_version) is NEWER than latest available ($latest_version)"
        saint_msg_status "info" "This usually means:"
        saint_msg_status "info" "  • You have local development changes"
        saint_msg_status "info" "  • GitHub repository is outdated"
        saint_msg_status "info" "  • You're ahead of the remote repository"
        saint_msg_status "info" "No update needed - you're already ahead!"
        return 1
    fi
    
    local update_type=$(saint_compare_versions "$current_version" "$latest_version")
    local comparison_result=$?
    
    if [ $comparison_result -eq 0 ] && [ -n "$update_type" ]; then
        saint_debug "Update available: $update_type"
        saint_show_update_notification "$current_version" "$latest_version" "$update_type"
        return 0
    else
        saint_debug "No update needed or comparison failed"
        saint_msg_status "info" "Current version ($current_version) is up to date"
        return 1
    fi
}

# Perform automatic update check
saint_auto_check_update() {
    if saint_should_check_update; then
        saint_check_for_updates
        saint_mark_update_check
    fi
}

# Download and install update
saint_download_update() {
    local version="$1"
    local temp_dir="/tmp/saint_update_$$"
    local archive_url="${SAINT_GITHUB_ARCHIVE}/v${version}.tar.gz"
    
    # Validate version parameter
    if [ -z "$version" ] || ! [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        saint_msg_status "error" "Invalid version format: $version"
        return 1
    fi
    
    saint_msg_status "info" "Downloading Saint v${version}..."
    
    # Create temporary directory safely
    if ! mkdir -p "$temp_dir" 2>/dev/null; then
        saint_msg_status "error" "Failed to create temporary directory: $temp_dir"
        return 1
    fi
    
    # Validate temp directory was created and is safe
    if [ ! -d "$temp_dir" ] || [[ "$temp_dir" != /tmp/saint_update_* ]]; then
        saint_msg_status "error" "Invalid temporary directory path: $temp_dir"
        return 1
    fi
    
    cd "$temp_dir"
    
    # Download and extract
    if command -v curl &> /dev/null; then
        curl -L -o "saint-${version}.tar.gz" "$archive_url"
    elif command -v wget &> /dev/null; then
        wget -O "saint-${version}.tar.gz" "$archive_url"
    else
        saint_msg_status "error" "Neither curl nor wget is available"
        return 1
    fi
    
    # Validate downloaded file
    if [ ! -f "saint-${version}.tar.gz" ]; then
        saint_msg_status "error" "Failed to download update"
        cd "$original_dir" 2>/dev/null || cd "$HOME"
        rm -rf "$temp_dir" 2>/dev/null
        return 1
    fi
    
    # Validate file size (should be reasonable)
    local file_size=$(stat -f%z "saint-${version}.tar.gz" 2>/dev/null || stat -c%s "saint-${version}.tar.gz" 2>/dev/null || echo "0")
    if [ "$file_size" -lt 1000 ]; then  # Less than 1KB is suspicious
        saint_msg_status "error" "Downloaded file is too small ($file_size bytes), may be corrupted"
        cd "$original_dir" 2>/dev/null || cd "$HOME"
        rm -rf "$temp_dir" 2>/dev/null
        return 1
    fi
    
    # Extract archive
    if ! tar -xzf "saint-${version}.tar.gz"; then
        saint_msg_status "error" "Failed to extract update"
        cd "$original_dir" 2>/dev/null || cd "$HOME"
        rm -rf "$temp_dir" 2>/dev/null
        return 1
    fi
    
    # Find the extracted directory safely
    local extracted_dir=""
    for dir in saint-*; do
        if [ -d "$dir" ] && [[ "$dir" == saint-* ]]; then
            extracted_dir="$dir"
            break
        fi
    done
    
    if [ -z "$extracted_dir" ] || [ ! -d "$extracted_dir" ]; then
        saint_msg_status "error" "Failed to find extracted files or invalid directory structure"
        cd "$original_dir" 2>/dev/null || cd "$HOME"
        rm -rf "$temp_dir" 2>/dev/null
        return 1
    fi
    
    # Validate extracted directory contains expected files
    if [ ! -f "${extracted_dir}/.saint" ] || [ ! -d "${extracted_dir}/core" ]; then
        saint_msg_status "error" "Extracted directory does not contain valid Saint installation"
        cd "$original_dir" 2>/dev/null || cd "$HOME"
        rm -rf "$temp_dir" 2>/dev/null
        return 1
    fi
    
    saint_msg_status "info" "Installing update..."
    
    # Store current directory to return later
    local original_dir=$(pwd)
    
    # Create backup directory if it doesn't exist
    local backup_base_dir="${PROJECT_PATH}/backup"
    if [ ! -d "$backup_base_dir" ]; then
        mkdir -p "$backup_base_dir"
    fi
    
    # Backup current installation to protected backup folder
    local backup_dir="${backup_base_dir}/saint_backup_$(date +%Y%m%d_%H%M%S)"
    cp -r "${PROJECT_PATH}" "$backup_dir"
    
    # Copy new files (excluding user-specific directories and Git metadata)
    # Use rsync if available for better control, otherwise use cp with exclusions
    if command -v rsync &> /dev/null; then
        # Use rsync to preserve Git state and exclude user directories
        rsync -av --exclude='.git' --exclude='projects' --exclude='saint_temp' --exclude='backup' "${extracted_dir}/" "${PROJECT_PATH}/"
    else
        # Fallback to cp with manual exclusions
        # First, remove files that will be replaced (excluding user directories)
        find "${PROJECT_PATH}" -maxdepth 1 -not -name '.' -not -name '.git' -not -name 'projects' -not -name 'saint_temp' -not -name 'backup' -exec rm -rf {} \;
        
        # Copy new files
        cp -r "${extracted_dir}/"* "${PROJECT_PATH}/"
    fi
    
    # Preserve user projects and configuration
    if [ -d "${backup_dir}/projects" ]; then
        cp -r "${backup_dir}/projects" "${PROJECT_PATH}/"
    fi
    
    if [ -d "${backup_dir}/saint_temp" ]; then
        cp -r "${backup_dir}/saint_temp" "${PROJECT_PATH}/"
    fi
    
    # Preserve Git metadata to avoid showing files as modified
    if [ -d "${backup_dir}/.git" ]; then
        cp -r "${backup_dir}/.git" "${PROJECT_PATH}/"
    fi
    
    # Reset Git state to avoid showing files as modified
    cd "${PROJECT_PATH}"
    if [ -d ".git" ]; then
        # Reset any changes that might have been detected
        git reset --hard HEAD 2>/dev/null || true
        # Clean untracked files (but preserve user directories)
        git clean -fd --exclude=projects --exclude=saint_temp --exclude=backup 2>/dev/null || true
    fi
    
    # Return to original directory
    cd "$original_dir"
    
    # Clean up temp directory safely
    if [ -d "$temp_dir" ] && [[ "$temp_dir" == /tmp/saint_update_* ]]; then
        rm -rf "$temp_dir"
    fi
    
    saint_msg_status "success" "Saint updated to v${version} successfully!"
    saint_msg_status "info" "Backup saved to: ${backup_dir}"
    echo ""
    echo "🔄 Reloading Saint and updating commands automatically..."
    echo ""
    
    # Try to reload Saint automatically
    if saint_reload_saint; then
        saint_msg_status "success" "Saint reloaded successfully!"
        
        # Update all commands automatically for security and new features
        saint_msg_status "info" "Updating all commands automatically..."
        if saint_update_all_commands; then
            saint_msg_status "success" "All commands updated successfully!"
            saint_msg_status "success" "Update complete! You can now use all new features without restarting your terminal."
        else
            saint_msg_status "warning" "Command update failed, but Saint is still updated"
            saint_msg_status "info" "Run 'saint update-commands' manually to update commands"
        fi
    else
        saint_msg_status "error" "Automatic reload failed - this should not happen"
        saint_msg_status "info" "Please contact support or check the installation"
    fi
    echo ""
}

# Update all commands automatically after update
saint_update_all_commands() {
    local original_dir=$(pwd)
    
    # Navigate to Saint directory safely
    if [ ! -d "${PROJECT_PATH}" ]; then
        saint_debug "PROJECT_PATH not found: ${PROJECT_PATH}"
        return 1
    fi
    
    cd "${PROJECT_PATH}" || {
        saint_debug "Failed to navigate to PROJECT_PATH: ${PROJECT_PATH}"
        return 1
    }
    
    # Use existing functions instead of duplicating code
    saint_debug "Updating main commands template..."
    if saint_sync_main_commands; then
        saint_debug "Main commands template synced"
    else
        saint_debug "Failed to sync main commands template"
        cd "$original_dir"
        return 1
    fi
    
    saint_debug "Updating project commands..."
    if saint_update_project_commands; then
        saint_debug "Project commands updated"
    else
        saint_debug "Failed to update project commands"
        cd "$original_dir"
        return 1
    fi
    
    saint_debug "Rebuilding help system..."
    if saint_rebuild_help; then
        saint_debug "Help system rebuilt"
    else
        saint_debug "Failed to rebuild help system"
        cd "$original_dir"
        return 1
    fi
    
    # Return to original directory
    cd "$original_dir"
    
    saint_debug "All commands updated successfully"
    return 0
}

# Reload Saint in current shell
saint_reload_saint() {
    local saint_file=""
    
    # Try to find .saint file safely
    if [ -f "${HOME}/.saint" ]; then
        saint_file="${HOME}/.saint"
    elif [ -f "${PROJECT_PATH}/.saint" ]; then
        saint_file="${PROJECT_PATH}/.saint"
    else
        saint_debug "No .saint file found"
        return 1
    fi
    
    # Validate the file is safe to source
    if [ ! -r "$saint_file" ] || [ ! -f "$saint_file" ]; then
        saint_debug "Saint file is not readable or not a regular file"
        return 1
    fi
    
    # Try to reload Saint
    if source "$saint_file" 2>/dev/null; then
        saint_debug "Saint reloaded successfully"
        return 0
    else
        saint_debug "Failed to reload Saint"
        return 1
    fi
}

# Update command handler
saint_update_commands() {
    local command="$1"
    
    case "$command" in
        "check"|"")
            saint_msg_status "info" "Checking for updates..."
            saint_check_for_updates
            ;;
        "auto")
            saint_msg_status "info" "Checking for updates..."
            local latest_version=$(saint_get_latest_version)
            if [ -n "$latest_version" ]; then
                # Check if update is actually needed
                if [ "${SAINT_VERSION}" = "$latest_version" ]; then
                    saint_msg_status "info" "Already up to date! Current version: ${SAINT_VERSION}"
                    saint_msg_status "info" "No update needed."
                    return 0
                fi
                
                # Double-check: prevent downgrade
                if saint_is_version_newer "${SAINT_VERSION}" "$latest_version"; then
                    saint_msg_status "error" "ABORTED: This would be a downgrade!"
                    saint_msg_status "info" "Current version (${SAINT_VERSION}) is NEWER than latest available ($latest_version)"
                    saint_msg_status "info" "Use 'saint update force $latest_version' if you really want to downgrade"
                    return 1
                fi
                
                saint_msg_status "info" "Update available: ${SAINT_VERSION} → ${latest_version}"
                saint_download_update "$latest_version"
            else
                saint_msg_status "error" "Could not determine latest version"
            fi
            ;;
        "force")
            local version="$2"
            if [ -z "$version" ]; then
                saint_msg_status "error" "Version number required: saint update force <version>"
                return 1
            fi
            
            # Warn about potential downgrade
            if saint_is_version_newer "${SAINT_VERSION}" "$version"; then
                saint_msg_status "warning" "⚠️  WARNING: This will DOWNGRADE your installation!"
                saint_msg_status "info" "Current version: ${SAINT_VERSION}"
                saint_msg_status "info" "Target version: $version"
                saint_msg_status "info" "This will overwrite your local changes!"
                
                local confirm
                saint_read confirm "Are you sure you want to continue? (type 'yes' to confirm): "
                if [ "$confirm" != "yes" ]; then
                    saint_msg_status "info" "Update cancelled"
                    return 1
                fi
            fi
            
            saint_download_update "$version"
            ;;
        "status")
            echo ""
            echo "🤖 Saint Update Status"
            echo "======================"
            echo "Current Version: ${GREEN}${SAINT_VERSION}${NC}"
            echo "Last Check: ${YELLOW}$(if [ -f "${SAINT_UPDATE_CHECK_FILE}" ]; then 
                if date -r "${SAINT_UPDATE_CHECK_FILE}" 2>/dev/null; then 
                    : # Success, date was printed
                else
                    echo 'File exists but cannot read date'
                fi
            else 
                echo 'Never'
            fi)${NC}"
            echo "Check Interval: ${YELLOW}${SAINT_UPDATE_INTERVAL} days${NC}"
            echo ""
            ;;
        *)
            echo ""
            echo "🔄 Saint Update Commands"
            echo "========================"
            echo "check   - Check for available updates"
            echo "auto    - Automatically download and install latest version"
            echo "force   - Force update to specific version: saint update force <version>"
            echo "status  - Show update system status"
            echo ""
            echo "Examples:"
            echo "  saint update check    - Check for updates"
            echo "  saint update auto     - Auto-update to latest version"
            echo "  saint update force 1.1.0 - Force update to v1.1.0"
            echo ""
            ;;
    esac
}
